# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ..commons.errors.bad_request_error import BadRequestError
from ..commons.errors.not_found_error import NotFoundError
from ..commons.errors.server_error import ServerError
from ..commons.types.error_message import ErrorMessage
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.remove_none_from_dict import remove_none_from_dict
from ..core.request_options import RequestOptions
from .types.knowledge_base_request import KnowledgeBaseRequest
from .types.knowledge_base_response import KnowledgeBaseResponse
from .types.knowledge_base_version import KnowledgeBaseVersion
from .types.knowledge_document_request import KnowledgeDocumentRequest
from .types.knowledge_document_response import KnowledgeDocumentResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class KnowledgeClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_or_update_knowledge_base(
        self, *, request: KnowledgeBaseRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> KnowledgeBaseResponse:
        """
        Update a knowledge base or create it if it doesn't exist.

        Parameters:
            - request: KnowledgeBaseRequest.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi import EntityIdBase, KnowledgeBaseRequest
        from mavenagi.client import MavenAGI

        client = MavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        client.knowledge.create_or_update_knowledge_base(
            request=KnowledgeBaseRequest(
                knowledge_base_id=EntityIdBase(
                    reference_id="help-center",
                ),
                name="Help center",
                type="API",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/knowledge"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KnowledgeBaseResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_knowledge_base(
        self, knowledge_base_reference_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> KnowledgeBaseResponse:
        """
        Get an existing knowledge base by its supplied ID

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base to get. All other entity ID fields are inferred from the request.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi.client import MavenAGI

        client = MavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        client.knowledge.get_knowledge_base(
            knowledge_base_reference_id="help-center",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KnowledgeBaseResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_knowledge_base_version(
        self,
        knowledge_base_reference_id: str,
        *,
        request: KnowledgeBaseVersion,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KnowledgeBaseVersion:
        """
        Create a new knowledge base version. Only supported on API knowledge bases. Will throw an exception if there is an existing version in progress.

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base to create a version for. All other entity ID fields are inferred from the request.

            - request: KnowledgeBaseVersion.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi import KnowledgeBaseVersion
        from mavenagi.client import MavenAGI

        client = MavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        client.knowledge.create_knowledge_base_version(
            knowledge_base_reference_id="help-center",
            request=KnowledgeBaseVersion(
                type="FULL",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}/version",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KnowledgeBaseVersion, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def finalize_knowledge_base_version(
        self, knowledge_base_reference_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Finalize the latest knowledge base version. Required to indicate the version is complete. Will throw an exception if the latest version is not in progress.

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base to finalize a version for. All other entity ID fields are inferred from the request.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi.client import MavenAGI

        client = MavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        client.knowledge.finalize_knowledge_base_version(
            knowledge_base_reference_id="help-center",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}/version/finalize",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_knowledge_document(
        self,
        knowledge_base_reference_id: str,
        *,
        request: KnowledgeDocumentRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KnowledgeDocumentResponse:
        """
        Create knowledge document. Requires an existing knowledge base with an in progress version. Will throw an exception if the latest version is not in progress.

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base to create a document for. All other entity ID fields are inferred from the request.

            - request: KnowledgeDocumentRequest.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi import EntityIdBase, KnowledgeDocumentRequest
        from mavenagi.client import MavenAGI

        client = MavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        client.knowledge.create_knowledge_document(
            knowledge_base_reference_id="help-center",
            request=KnowledgeDocumentRequest(
                knowledge_document_id=EntityIdBase(
                    reference_id="getting-started",
                ),
                content_type="MARKDOWN",
                content="## Getting started\\nThis is a getting started guide for the help center.",
                title="Getting started",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}/document",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KnowledgeDocumentResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_knowledge_document(
        self,
        knowledge_base_reference_id: str,
        *,
        request: KnowledgeDocumentRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KnowledgeDocumentResponse:
        """
        Not yet implemented. Update knowledge document. Requires an existing knowledge base with an in progress version of type PARTIAL. Will throw an exception if the latest version is not in progress.

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base that contains the document to update. All other entity ID fields are inferred from the request.

            - request: KnowledgeDocumentRequest.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi import EntityIdBase, KnowledgeDocumentRequest
        from mavenagi.client import MavenAGI

        client = MavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        client.knowledge.update_knowledge_document(
            knowledge_base_reference_id="help-center",
            request=KnowledgeDocumentRequest(
                knowledge_document_id=EntityIdBase(
                    reference_id="getting-started",
                ),
                content_type="MARKDOWN",
                content="## Getting started\\nThis is a getting started guide for the help center.",
                title="Getting started",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}/document",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KnowledgeDocumentResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_knowledge_document(
        self,
        knowledge_base_reference_id: str,
        knowledge_document_reference_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Not yet implemented. Delete knowledge document. Requires an existing knowledge base with an in progress version of type PARTIAL. Will throw an exception if the latest version is not in progress.

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base that contains the document to delete. All other entity ID fields are inferred from the request

            - knowledge_document_reference_id: str. The reference ID of the knowledge document to delete. All other entity ID fields are inferred from the request.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi.client import MavenAGI

        client = MavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        client.knowledge.delete_knowledge_document(
            knowledge_base_reference_id="help-center",
            knowledge_document_reference_id="getting-started",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}/{jsonable_encoder(knowledge_document_reference_id)}/document",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncKnowledgeClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_or_update_knowledge_base(
        self, *, request: KnowledgeBaseRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> KnowledgeBaseResponse:
        """
        Update a knowledge base or create it if it doesn't exist.

        Parameters:
            - request: KnowledgeBaseRequest.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi import EntityIdBase, KnowledgeBaseRequest
        from mavenagi.client import AsyncMavenAGI

        client = AsyncMavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        await client.knowledge.create_or_update_knowledge_base(
            request=KnowledgeBaseRequest(
                knowledge_base_id=EntityIdBase(
                    reference_id="help-center",
                ),
                name="Help center",
                type="API",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v1/knowledge"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KnowledgeBaseResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_knowledge_base(
        self, knowledge_base_reference_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> KnowledgeBaseResponse:
        """
        Get an existing knowledge base by its supplied ID

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base to get. All other entity ID fields are inferred from the request.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi.client import AsyncMavenAGI

        client = AsyncMavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        await client.knowledge.get_knowledge_base(
            knowledge_base_reference_id="help-center",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KnowledgeBaseResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_knowledge_base_version(
        self,
        knowledge_base_reference_id: str,
        *,
        request: KnowledgeBaseVersion,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KnowledgeBaseVersion:
        """
        Create a new knowledge base version. Only supported on API knowledge bases. Will throw an exception if there is an existing version in progress.

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base to create a version for. All other entity ID fields are inferred from the request.

            - request: KnowledgeBaseVersion.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi import KnowledgeBaseVersion
        from mavenagi.client import AsyncMavenAGI

        client = AsyncMavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        await client.knowledge.create_knowledge_base_version(
            knowledge_base_reference_id="help-center",
            request=KnowledgeBaseVersion(
                type="FULL",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}/version",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KnowledgeBaseVersion, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def finalize_knowledge_base_version(
        self, knowledge_base_reference_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Finalize the latest knowledge base version. Required to indicate the version is complete. Will throw an exception if the latest version is not in progress.

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base to finalize a version for. All other entity ID fields are inferred from the request.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi.client import AsyncMavenAGI

        client = AsyncMavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        await client.knowledge.finalize_knowledge_base_version(
            knowledge_base_reference_id="help-center",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}/version/finalize",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_knowledge_document(
        self,
        knowledge_base_reference_id: str,
        *,
        request: KnowledgeDocumentRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KnowledgeDocumentResponse:
        """
        Create knowledge document. Requires an existing knowledge base with an in progress version. Will throw an exception if the latest version is not in progress.

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base to create a document for. All other entity ID fields are inferred from the request.

            - request: KnowledgeDocumentRequest.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi import EntityIdBase, KnowledgeDocumentRequest
        from mavenagi.client import AsyncMavenAGI

        client = AsyncMavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        await client.knowledge.create_knowledge_document(
            knowledge_base_reference_id="help-center",
            request=KnowledgeDocumentRequest(
                knowledge_document_id=EntityIdBase(
                    reference_id="getting-started",
                ),
                content_type="MARKDOWN",
                content="## Getting started\\nThis is a getting started guide for the help center.",
                title="Getting started",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}/document",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KnowledgeDocumentResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_knowledge_document(
        self,
        knowledge_base_reference_id: str,
        *,
        request: KnowledgeDocumentRequest,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> KnowledgeDocumentResponse:
        """
        Not yet implemented. Update knowledge document. Requires an existing knowledge base with an in progress version of type PARTIAL. Will throw an exception if the latest version is not in progress.

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base that contains the document to update. All other entity ID fields are inferred from the request.

            - request: KnowledgeDocumentRequest.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi import EntityIdBase, KnowledgeDocumentRequest
        from mavenagi.client import AsyncMavenAGI

        client = AsyncMavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        await client.knowledge.update_knowledge_document(
            knowledge_base_reference_id="help-center",
            request=KnowledgeDocumentRequest(
                knowledge_document_id=EntityIdBase(
                    reference_id="getting-started",
                ),
                content_type="MARKDOWN",
                content="## Getting started\\nThis is a getting started guide for the help center.",
                title="Getting started",
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PUT",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}/document",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(KnowledgeDocumentResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_knowledge_document(
        self,
        knowledge_base_reference_id: str,
        knowledge_document_reference_id: str,
        *,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> None:
        """
        Not yet implemented. Delete knowledge document. Requires an existing knowledge base with an in progress version of type PARTIAL. Will throw an exception if the latest version is not in progress.

        Parameters:
            - knowledge_base_reference_id: str. The reference ID of the knowledge base that contains the document to delete. All other entity ID fields are inferred from the request

            - knowledge_document_reference_id: str. The reference ID of the knowledge document to delete. All other entity ID fields are inferred from the request.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from mavenagi.client import AsyncMavenAGI

        client = AsyncMavenAGI(
            organization_id="YOUR_ORGANIZATION_ID",
            agent_id="YOUR_AGENT_ID",
            app_id="YOUR_APP_ID",
            app_secret="YOUR_APP_SECRET",
        )
        await client.knowledge.delete_knowledge_document(
            knowledge_base_reference_id="help-center",
            knowledge_document_reference_id="getting-started",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"v1/knowledge/{jsonable_encoder(knowledge_base_reference_id)}/{jsonable_encoder(knowledge_document_reference_id)}/document",
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise ServerError(pydantic.parse_obj_as(ErrorMessage, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
