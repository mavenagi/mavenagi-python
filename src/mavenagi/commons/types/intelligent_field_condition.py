# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

import pydantic
import typing_extensions
from ...core.pydantic_utilities import IS_PYDANTIC_V2, UniversalBaseModel
from ...core.serialization import FieldMetadata
from .numeric_condition import NumericCondition
from .set_condition import SetCondition
from .string_condition import StringCondition


class IntelligentFieldCondition_String(UniversalBaseModel):
    value: StringCondition
    field_validation_type: typing_extensions.Annotated[
        typing.Literal["string"], FieldMetadata(alias="fieldValidationType")
    ] = "string"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True


class IntelligentFieldCondition_Numeric(UniversalBaseModel):
    value: NumericCondition
    field_validation_type: typing_extensions.Annotated[
        typing.Literal["numeric"], FieldMetadata(alias="fieldValidationType")
    ] = "numeric"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True


class IntelligentFieldCondition_Boolean(UniversalBaseModel):
    """
    The condition to evaluate against an intelligent field's value.
    Use the appropriate type based on the field's validationType:
    - `string`: For STRING and MULTILINE fields
    - `numeric`: For NUMBER fields
    - `boolean`: For BOOLEAN fields
    - `set`: For MULTI_SELECT fields (unordered set of values)

    Note: single select fields are represented as STRING/NUMBER with a list of
    enumOptions.

    The caller is responsible for querying the validationType and enumOptions
    from the intelligent field API to ensure the values are valid enumOptions.
    """

    field_validation_type: typing_extensions.Annotated[
        typing.Literal["boolean"], FieldMetadata(alias="fieldValidationType")
    ] = "boolean"
    value: bool

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow


class IntelligentFieldCondition_Set(UniversalBaseModel):
    value: SetCondition
    field_validation_type: typing_extensions.Annotated[
        typing.Literal["set"], FieldMetadata(alias="fieldValidationType")
    ] = "set"

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True


IntelligentFieldCondition = typing.Union[
    IntelligentFieldCondition_String,
    IntelligentFieldCondition_Numeric,
    IntelligentFieldCondition_Boolean,
    IntelligentFieldCondition_Set,
]
